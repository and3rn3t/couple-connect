#!/usr/bin/env node

/**
 * GitHub Deployment Status Manager with Performance Metrics
 * Creates deployment environments with timing data and performance insights
 */

import { Octokit } from '@octokit/rest';

class GitHubDeploymentManager {
  constructor() {
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN,
    });

    this.owner = process.env.GITHUB_REPOSITORY_OWNER;
    this.repo = process.env.GITHUB_REPOSITORY?.split('/')[1];
    this.sha = process.env.GITHUB_SHA;
    this.runId = process.env.GITHUB_RUN_ID;
  }

  async createDeploymentWithTiming(environment, startTime, metadata = {}) {
    const duration = Math.round((Date.now() - startTime) / 1000);

    try {
      // Create deployment
      const deployment = await this.octokit.repos.createDeployment({
        owner: this.owner,
        repo: this.repo,
        ref: this.sha,
        environment: environment,
        description: `Deployment to ${environment} - ${duration}s build time`,
        payload: {
          buildDuration: duration,
          timestamp: new Date().toISOString(),
          runId: this.runId,
          ...metadata,
        },
        auto_merge: false,
        required_contexts: [],
      });

      console.log(`ðŸš€ Created deployment for ${environment} (${duration}s)`);
      return deployment.data;
    } catch (error) {
      console.error(`Failed to create deployment: ${error.message}`);
      throw error;
    }
  }

  async updateDeploymentStatus(deploymentId, state, options = {}) {
    const { description, environment_url, log_url, timing } = options;

    let statusDescription = description || `Deployment ${state}`;
    if (timing) {
      statusDescription += ` (${timing.total}s total, ${timing.deploy}s deploy)`;
    }

    try {
      await this.octokit.repos.createDeploymentStatus({
        owner: this.owner,
        repo: this.repo,
        deployment_id: deploymentId,
        state: state,
        description: statusDescription,
        environment_url,
        log_url:
          log_url || `https://github.com/${this.owner}/${this.repo}/actions/runs/${this.runId}`,
      });

      console.log(`ðŸ“Š Updated deployment status: ${state} - ${statusDescription}`);
    } catch (error) {
      console.error(`Failed to update deployment status: ${error.message}`);
      throw error;
    }
  }

  async createPerformancePR(performanceData, baselineData) {
    const timingComparison = this.generateTimingComparison(performanceData, baselineData);

    const body = `## ðŸ“Š Performance Report

### ðŸš€ Workflow Timing Analysis

${timingComparison}

### ðŸ“ˆ Key Metrics

| Metric | Current | Baseline | Change |
|--------|---------|----------|--------|
| Total Time | ${performanceData.totalTime}s | ${baselineData.totalTime}s | ${this.calculateChange(performanceData.totalTime, baselineData.totalTime)} |
| Build Time | ${performanceData.buildTime}s | ${baselineData.buildTime}s | ${this.calculateChange(performanceData.buildTime, baselineData.buildTime)} |
| Test Time | ${performanceData.testTime}s | ${baselineData.testTime}s | ${this.calculateChange(performanceData.testTime, baselineData.testTime)} |

### ðŸŽ¯ Recommendations

${this.generateRecommendations(performanceData)}

---
*Generated by GitHub Actions Performance Monitor*`;

    return {
      title: 'ðŸ“Š Performance Analysis Report',
      body: body,
    };
  }

  generateTimingComparison(current, baseline) {
    const comparison = [];

    ['totalTime', 'buildTime', 'testTime', 'setupTime'].forEach((metric) => {
      const currentVal = current[metric] || 0;
      const baselineVal = baseline[metric] || 0;
      const change = this.calculateChange(currentVal, baselineVal);
      const trend = currentVal < baselineVal ? 'ðŸ“ˆ' : currentVal > baselineVal ? 'ðŸ“‰' : 'âž¡ï¸';

      comparison.push(`- ${metric}: ${currentVal}s (${change}) ${trend}`);
    });

    return comparison.join('\n');
  }

  calculateChange(current, baseline) {
    if (!baseline) return 'N/A';
    const change = (((current - baseline) / baseline) * 100).toFixed(1);
    const sign = change > 0 ? '+' : '';
    return `${sign}${change}%`;
  }

  generateRecommendations(data) {
    const recommendations = [];

    if (data.totalTime > 600) {
      recommendations.push(
        'ðŸš¨ Total pipeline time exceeds 10 minutes - consider parallel optimization'
      );
    }

    if (data.buildTime > 180) {
      recommendations.push('ðŸ—ï¸ Build time high - consider incremental builds or better caching');
    }

    if (data.testTime > 300) {
      recommendations.push('ðŸ§ª Test time high - consider test parallelization or selection');
    }

    if (data.setupTime > 90) {
      recommendations.push('âš¡ Setup time high - optimize dependency caching');
    }

    if (recommendations.length === 0) {
      recommendations.push('âœ… Performance looks good! All metrics within optimal ranges.');
    }

    return recommendations.join('\n');
  }
}

export default GitHubDeploymentManager;
